## 钉钉集成与部署方案

本方案在不大改现有代码的前提下，为系统增加“仅钉钉可用”的访问控制：
- 前端：仅在钉钉容器中运行，使用钉钉 H5 微应用免登获取 `authCode`
- 后端：用 `authCode` 向钉钉获取用户身份并签发服务端会话（HttpOnly Cookie/JWT）
- 网关：Nginx 软拦截非钉钉 UA 与来源，HTTPS、限流与上传限制
- 部署：提供 Docker Compose 与 PM2 + Nginx 两套落地方案
- 升级回滚：灰度开关、数据与配置不丢失

---

### 一、准备工作（钉钉开放平台）
- 创建“企业内部 H5 微应用”，拿到：
  - 企业 `corpId`
  - 应用 `appKey`、`appSecret`
- 在微应用配置中：
  - 绑定可信域名（指向前端站点域名）
  - 勾选“免登”能力
  - 如需更严密，可配置服务器出口 IP 白名单

参考接口（经典与新版兼容二选一）：
- 获取企业 `access_token`（经典）：`GET https://oapi.dingtalk.com/gettoken?appkey=xxx&appsecret=yyy`
- 通过免登码获取用户（经典）：`GET https://oapi.dingtalk.com/user/getuserinfo?access_token=...&code=...`
- 新版 TopAPI（推荐）：`POST https://oapi.dingtalk.com/topapi/v2/user/getuserinfo`（Header 带入 `access_token`，Body 含 `code`）

---

### 二、后端改造（最小侵入）
后端统一在成功免登后写入会话 Cookie，所有业务接口必须通过鉴权中间件。以下示例以现有 Express 项目为基准。

- 新增环境变量（`.env`）
```
DINGTALK_AUTH_ENABLED=true
DINGTALK_CORP_ID=dingxxxx
DINGTALK_APP_KEY=xxx
DINGTALK_APP_SECRET=xxx
PORT=3002            # 与 backend/src/index.ts 默认一致
NODE_ENV=production
MODEL_ENCRYPTION_KEY=请替换为强随机值
```

- 新增 `backend/src/services/dingtalkService.ts`
```ts
import axios from 'axios';

let cachedToken = '';
let tokenExpireAt = 0;

async function getAccessToken(): Promise<string> {
  const now = Date.now();
  if (cachedToken && now < tokenExpireAt - 60_000) return cachedToken;

  const appKey = process.env.DINGTALK_APP_KEY;
  const appSecret = process.env.DINGTALK_APP_SECRET;
  if (!appKey || !appSecret) throw new Error('缺少钉钉密钥配置');

  const resp = await axios.get('https://oapi.dingtalk.com/gettoken', {
    params: { appkey: appKey, appsecret: appSecret }
  });
  if (resp.data.errcode !== 0) throw new Error(`gettoken 失败: ${resp.data.errmsg}`);
  cachedToken = resp.data.access_token;
  tokenExpireAt = Date.now() + 7_000_000; // 官方约 7200s，此处留余量
  return cachedToken;
}

export async function getUserByAuthCode(authCode: string): Promise<{ userId: string; unionId?: string }>{
  const accessToken = await getAccessToken();

  // 尝试 TopAPI v2
  try {
    const v2 = await axios.post(
      'https://oapi.dingtalk.com/topapi/v2/user/getuserinfo',
      { code: authCode },
      { params: { access_token: accessToken } }
    );
    if (v2.data.errcode === 0 && v2.data.result) {
      const { userid, unionid } = v2.data.result;
      return { userId: userid, unionId: unionid };
    }
  } catch {}

  // 兼容经典接口
  const resp = await axios.get('https://oapi.dingtalk.com/user/getuserinfo', {
    params: { access_token: accessToken, code: authCode }
  });
  if (resp.data.errcode !== 0) throw new Error(`getuserinfo 失败: ${resp.data.errmsg}`);
  return { userId: resp.data.userid, unionId: resp.data.unionid };
}
```

- 新增 `backend/src/middlewares/auth.ts`
```ts
import type { Request, Response, NextFunction } from 'express';

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (process.env.DINGTALK_AUTH_ENABLED !== 'true') return next();
  const user = (req as any).user;
  if (!user) {
    return res.status(401).json({ success: false, message: '未登录或登录已失效' });
  }
  next();
}
```

- 新增 `backend/src/routes/auth.ts`
```ts
import express from 'express';
import { getUserByAuthCode } from '../services/dingtalkService';

const router = express.Router();

// 简单基于 Cookie 的会话（生产可替换为 JWT + Redis）
router.post('/dingtalk/login', async (req, res) => {
  try {
    const { authCode } = req.body || {};
    if (!authCode) return res.status(400).json({ success: false, message: '缺少 authCode' });

    const user = await getUserByAuthCode(authCode);
    // 生成会话（示例：将用户写入内存/签名 Token），这里演示最小化：
    const session = {
      userId: user.userId,
      unionId: user.unionId,
      ts: Date.now()
    };

    // 简化：写入 Base64（示例用，生产请使用签名 JWT/Session Store）
    const payload = Buffer.from(JSON.stringify(session)).toString('base64');
    res.cookie('wd_sess', payload, {
      httpOnly: true,
      secure: true,
      sameSite: 'lax',
      maxAge: 12 * 60 * 60 * 1000
    });
    res.json({ success: true });
  } catch (e: any) {
    res.status(500).json({ success: false, message: e?.message || '登录失败' });
  }
});

router.get('/me', (req, res) => {
  const user = (req as any).user;
  if (!user) return res.status(401).json({ success: false });
  res.json({ success: true, data: user });
});

export default router;
```

- 在 `backend/src/index.ts` 集成（要点）
```ts
import cookieParser from 'cookie-parser';
import authRoutes from './routes/auth';
import { requireAuth } from './middlewares/auth';

app.use(cookieParser());

// 解析 Cookie -> 注入 req.user（示例，生产用 JWT 校验）
app.use((req, _res, next) => {
  try {
    const raw = (req as any).cookies?.wd_sess;
    if (raw) {
      const json = JSON.parse(Buffer.from(raw, 'base64').toString('utf8'));
      (req as any).user = json;
    }
  } catch {}
  next();
});

app.use('/api/auth', authRoutes);

// 从这里开始的业务接口全部强制鉴权
app.use('/api/templates', requireAuth, templateRoutes);
app.use('/api/models', requireAuth, modelRoutes);
app.use('/api/documents', requireAuth, documentRoutes);
app.use('/api/word-import', requireAuth, wordImportRoutes);
app.use('/api/ai-gpt', requireAuth, aiGptRoutes);
app.use('/api/images', requireAuth, imageRoutes);
```

> 说明：上面的会话实现演示“最小成活”。正式生产建议改为：后端签发 JWT（`HttpOnly` Cookie + 签名密钥）或服务端 Session（Redis），并增加 CSRF 防护与 Token 过期刷新。

---

### 三、前端改造（最小侵入）
仅在钉钉容器中渲染应用，非钉钉环境展示“请从钉钉打开”。

- 安装依赖
```
npm i dingtalk-jsapi
```

- 在 `frontend/.env`（或构建环境）增加：
```
VITE_DD_CORP_ID=dingxxxx
VITE_API_BASE_URL=/api
```

- 在 `frontend/src/main.tsx` 或顶层组件做初始化（伪代码要点）
```ts
import * as dd from 'dingtalk-jsapi';
import api from './services/api';

async function bootstrap() {
  const isDd = /DingTalk/i.test(navigator.userAgent);
  if (!isDd) {
    renderOnlyDingTalkHint();
    return;
  }

  try {
    await new Promise((resolve, reject) => dd.ready(resolve as any));
    const corpId = import.meta.env.VITE_DD_CORP_ID;
    const { code } = await dd.runtime.permission.requestAuthCode({ corpId });
    await api.post('/auth/dingtalk/login', { authCode: code });
    renderApp();
  } catch (e) {
    renderOnlyDingTalkHint('免登失败，请重试或联系管理员');
  }
}

bootstrap();
```

- Axios 携带 Cookie，并在 401 时尝试重登
```ts
// services/api.ts 中创建 axios 实例时：
const api = axios.create({ baseURL: import.meta.env.VITE_API_BASE_URL, withCredentials: true });
api.interceptors.response.use(r => r, async (error) => {
  if (error?.response?.status === 401 && /DingTalk/i.test(navigator.userAgent)) {
    try {
      const corpId = import.meta.env.VITE_DD_CORP_ID;
      const { code } = await (window as any).dd.runtime.permission.requestAuthCode({ corpId });
      await api.post('/auth/dingtalk/login', { authCode: code });
      // 重放原请求
      return api(error.config);
    } catch {}
  }
  return Promise.reject(error);
});
```

> 如需更严谨防“非钉钉内嵌 WebView”，可接入 `dd.config` + `jsapi_ticket` 服务端签名校验。

---

### 四、Nginx/网关加固（可选但推荐）
软拦截非钉钉 UA 与来源，最终安全仍以后端会话校验为准。

```nginx
server {
  listen 80;
  server_name your-domain.com;
  return 301 https://$host$request_uri;
}

server {
  listen 443 ssl http2;
  server_name your-domain.com;
  # ssl_certificate /path/fullchain.cer;
  # ssl_certificate_key /path/privkey.key;

  # 前端静态
  root /usr/share/nginx/html;
  index index.html;

  # 仅允许钉钉 UA（软拦截）
  if ($http_user_agent !~* "DingTalk") { return 403; }

  # SPA 回退
  location / {
    try_files $uri /index.html;
  }

  # 反代后端
  location /api/ {
    proxy_pass http://backend:3002/;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }

  # 上传大小限制
  client_max_body_size 12m;
}
```

---

### 五、Docker Compose 部署
目录持久化：`backend/data/models`、`backend/data/templates`、`backend/uploads`

```yaml
version: '3.9'
services:
  backend:
    build:
      context: .
      dockerfile: backend/Dockerfile
    environment:
      NODE_ENV: production
      PORT: 3002
      DINGTALK_AUTH_ENABLED: 'true'
      DINGTALK_CORP_ID: ${DINGTALK_CORP_ID}
      DINGTALK_APP_KEY: ${DINGTALK_APP_KEY}
      DINGTALK_APP_SECRET: ${DINGTALK_APP_SECRET}
      MODEL_ENCRYPTION_KEY: ${MODEL_ENCRYPTION_KEY}
    volumes:
      - ./backend/data/models:/app/data/models
      - ./backend/data/templates:/app/data/templates
      - ./backend/uploads:/app/uploads
    expose:
      - '3002'

  frontend:
    build:
      context: .
      dockerfile: frontend/Dockerfile
    environment:
      VITE_API_BASE_URL: /api
      VITE_DD_CORP_ID: ${DINGTALK_CORP_ID}

  nginx:
    image: nginx:alpine
    depends_on:
      - backend
      - frontend
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ./frontend/dist:/usr/share/nginx/html:ro
```

> 注意：生产环境建议由 CI 将 `frontend/dist` 打包产物下发到镜像或挂载卷；证书部署请替换为实际路径。

---

### 六、PM2 + Nginx 部署
- 后端
  - Node 18，安装依赖并构建：`npm ci && npm run build`
  - `pm2 start dist/index.js --name word-backend -i max`
  - `.env` 配置同上
- 前端
  - `npm ci && npm run build`
  - Nginx 托管 `dist` 并反代 `/api` 到 `http://127.0.0.1:3002`

`ecosystem.config.js` 示例：
```js
module.exports = {
  apps: [{
    name: 'word-backend',
    script: 'dist/index.js',
    env: { NODE_ENV: 'production', PORT: 3002 }
  }]
}
```

---

### 七、升级与回滚
- 灰度开关：先上线后端代码但关闭 `DINGTALK_AUTH_ENABLED`，确认稳定后开启
- 升级顺序：后端 → 打开开关 → 前端（含免登逻辑）
- 回滚：关闭开关或回退前端；卷内数据不变
- 变更注意
  - `MODEL_ENCRYPTION_KEY` 一旦更改会影响历史模型密钥解密，不建议变更
  - 如会话改为 JWT，需配置签名密钥轮换策略

---

### 八、安全与合规清单
- 后端仅信任服务端会话（HttpOnly + Secure），所有业务接口挂 `requireAuth`
- CORS（如启用）严格限定到前端域名；生产全站 HTTPS + HSTS
- 上传大小限制与文件类型校验
- 速率限制已在后端启用（`express-rate-limit`），Nginx 可再限流
- 日志脱敏（不落盘 `authCode` 与密钥）

---

### 九、验证用例（上线前自测）
- [钉钉内] 首次访问：能弹免登、登录成功并浏览各页面
- [钉钉内] 会话过期（清 Cookie）：自动重新免登后恢复
- [浏览器直开] 被拦截（前端提示 + Nginx 403）
- [API 直调] 无 Cookie 时返回 401
- 模板/模型 CRUD、Word 导入与图片上传在钉钉内可正常使用

---

### 十、常见问题
- 免登报错 `permission denied`：检查钉钉微应用可信域名与 JSAPI 权限范围
- `authCode` 有效期极短：必须前端获取后立即发给后端换取用户，不要缓存
- 非钉钉浏览器需要调试：将 `DINGTALK_AUTH_ENABLED=false`，便于本地开发

---

如需我直接在后端接入上述文件与路由、中间件（真实代码），可告知我采用 JWT 还是服务端 Session（Redis），我会按你选择落地并自测通过后提交。 


